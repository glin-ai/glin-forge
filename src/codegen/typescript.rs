// Enhanced TypeScript code generation from ink! contract metadata
//
// This module generates comprehensive TypeScript interfaces with full type safety,
// including separate interfaces for queries, transactions, events, and deployment.

use anyhow::{Context, Result};
use serde_json::Value as JsonValue;

use super::type_resolver::{TypeResolver, TypeScriptType, UnionVariant};

/// Generate complete TypeScript module from contract metadata
pub fn generate_typescript_module(contract_name: &str, metadata: &JsonValue) -> Result<String> {
    let mut generator = TypeScriptGenerator::new(contract_name, metadata)?;
    generator.generate()
}

/// TypeScript code generator
struct TypeScriptGenerator {
    contract_name: String,
    type_resolver: TypeResolver,
    metadata: JsonValue,
}

impl TypeScriptGenerator {
    fn new(contract_name: &str, metadata: &JsonValue) -> Result<Self> {
        // Get types section (handle both V3 and V4 format)
        let types_section = if let Some(v3) = metadata.get("V3") {
            &v3["types"]
        } else {
            metadata.get("types").context("Types section not found")?
        };

        let type_resolver = TypeResolver::new(types_section)?;

        Ok(Self {
            contract_name: contract_name.to_string(),
            type_resolver,
            metadata: metadata.clone(),
        })
    }

    /// Generate the complete TypeScript module
    fn generate(&mut self) -> Result<String> {
        let mut output = String::new();

        // Header
        output.push_str(&self.generate_header());

        // Imports
        output.push_str(&self.generate_imports());

        // Custom type definitions (structs, enums)
        output.push_str(&self.generate_custom_types()?);

        // Constructor interface
        output.push_str(&self.generate_constructor_interface()?);

        // Methods interface (separated into queries and transactions)
        output.push_str(&self.generate_methods_interface()?);

        // Events interface
        output.push_str(&self.generate_events_interface()?);

        // Main contract interface
        output.push_str(&self.generate_main_interface()?);

        Ok(output)
    }

    /// Generate file header with metadata
    fn generate_header(&self) -> String {
        format!(
            r#"/**
 * TypeScript definitions for {} contract
 *
 * Generated by glin-forge typegen
 * DO NOT EDIT MANUALLY
 */

"#,
            self.contract_name
        )
    }

    /// Generate import statements
    fn generate_imports(&self) -> String {
        format!(
            r#"import type {{
  Contract,
  Transaction,
  Network,
  Signer,
  ContractEvent,
}} from '@glin-forge/sdk';

"#
        )
    }

    /// Generate custom type definitions (structs and enums)
    fn generate_custom_types(&mut self) -> Result<String> {
        let mut output = String::new();

        // Get spec section
        let spec = self.get_spec_section();

        // Extract types from constructors, messages, and events
        let mut type_ids = Vec::new();

        // From constructors
        if let Some(constructors) = spec["constructors"].as_array() {
            for ctor in constructors {
                if let Some(args) = ctor["args"].as_array() {
                    for arg in args {
                        if let Some(type_id) = arg["type"]["type"].as_u64() {
                            type_ids.push(type_id as u32);
                        }
                    }
                }
            }
        }

        // From messages
        if let Some(messages) = spec["messages"].as_array() {
            for msg in messages {
                if let Some(args) = msg["args"].as_array() {
                    for arg in args {
                        if let Some(type_id) = arg["type"]["type"].as_u64() {
                            type_ids.push(type_id as u32);
                        }
                    }
                }
                if let Some(return_type) = msg.get("returnType") {
                    if let Some(type_id) = return_type["type"].as_u64() {
                        type_ids.push(type_id as u32);
                    }
                }
            }
        }

        // From events
        if let Some(events) = spec["events"].as_array() {
            for event in events {
                if let Some(args) = event["args"].as_array() {
                    for arg in args {
                        if let Some(type_id) = arg["type"]["type"].as_u64() {
                            type_ids.push(type_id as u32);
                        }
                    }
                }
            }
        }

        // Resolve all types and collect custom types
        let mut custom_types = Vec::new();
        for type_id in type_ids {
            let ts_type = self.type_resolver.resolve_type(type_id)?;
            match ts_type {
                TypeScriptType::Interface { .. } | TypeScriptType::Union { .. } => {
                    if !custom_types.iter().any(|t| self.types_equal(t, &ts_type)) {
                        custom_types.push(ts_type);
                    }
                }
                _ => {}
            }
        }

        // Generate custom type definitions
        if !custom_types.is_empty() {
            output.push_str("// ========================================\n");
            output.push_str("// Custom Types\n");
            output.push_str("// ========================================\n\n");

            for ts_type in custom_types {
                output.push_str(&self.generate_type_definition(&ts_type)?);
                output.push_str("\n");
            }
        }

        Ok(output)
    }

    /// Generate a type definition (interface or union)
    fn generate_type_definition(&self, ts_type: &TypeScriptType) -> Result<String> {
        match ts_type {
            TypeScriptType::Interface { name, fields, docs } => {
                let mut output = String::new();

                // JSDoc
                if !docs.is_empty() {
                    output.push_str("/**\n");
                    for doc in docs {
                        output.push_str(&format!(" * {}\n", doc));
                    }
                    output.push_str(" */\n");
                }

                output.push_str(&format!("export interface {} {{\n", name));
                for (field_name, field_type) in fields {
                    output.push_str(&format!(
                        "  {}: {};\n",
                        field_name,
                        self.type_resolver.format_type(field_type)
                    ));
                }
                output.push_str("}\n");

                Ok(output)
            }
            TypeScriptType::Union { name, variants, docs } => {
                let mut output = String::new();

                // JSDoc
                if !docs.is_empty() {
                    output.push_str("/**\n");
                    for doc in docs {
                        output.push_str(&format!(" * {}\n", doc));
                    }
                    output.push_str(" */\n");
                }

                output.push_str(&format!("export type {} =\n", name));

                for (i, variant) in variants.iter().enumerate() {
                    let separator = if i == 0 { "  " } else { "| " };

                    if variant.fields.is_empty() {
                        // Unit variant: { type: 'VariantName' }
                        output.push_str(&format!("{}{{ type: '{}' }}\n", separator, variant.name));
                    } else if variant.fields.len() == 1 && variant.fields[0].0.is_some() {
                        // Single named field: { type: 'VariantName', field: T }
                        let (field_name, field_type) = &variant.fields[0];
                        output.push_str(&format!(
                            "{}{{ type: '{}', {}: {} }}\n",
                            separator,
                            variant.name,
                            field_name.as_ref().unwrap(),
                            self.type_resolver.format_type(field_type)
                        ));
                    } else {
                        // Multiple fields: { type: 'VariantName', field1: T1, field2: T2 }
                        output.push_str(&format!("{}{{ type: '{}'", separator, variant.name));
                        for (field_name, field_type) in &variant.fields {
                            let name = field_name.as_ref().map(|s| s.as_str()).unwrap_or("value");
                            output.push_str(&format!(
                                ", {}: {}",
                                name,
                                self.type_resolver.format_type(field_type)
                            ));
                        }
                        output.push_str(" }\n");
                    }
                }

                output.push_str(";\n");

                Ok(output)
            }
            _ => Ok(String::new()),
        }
    }

    /// Generate constructor interface
    fn generate_constructor_interface(&mut self) -> Result<String> {
        let mut output = String::new();

        output.push_str("// ========================================\n");
        output.push_str("// Constructors\n");
        output.push_str("// ========================================\n\n");

        let spec = self.get_spec_section();
        let constructors = spec["constructors"]
            .as_array()
            .context("Constructors section missing")?;

        output.push_str(&format!(
            "export interface {}Constructors {{\n",
            self.contract_name
        ));

        for ctor in constructors {
            let label = ctor["label"].as_str().unwrap_or("new");
            let docs = ctor["docs"].as_array();

            // JSDoc
            if let Some(docs) = docs {
                if !docs.is_empty() {
                    output.push_str("  /**\n");
                    for doc in docs {
                        if let Some(doc_str) = doc.as_str() {
                            output.push_str(&format!("   * {}\n", doc_str));
                        }
                    }
                    output.push_str("   */\n");
                }
            }

            // Method signature
            output.push_str(&format!("  {}(\n", label));

            // Arguments
            if let Some(args) = ctor["args"].as_array() {
                for arg in args {
                    let arg_name = arg["label"].as_str().unwrap_or("arg");
                    let type_id = arg["type"]["type"].as_u64().unwrap_or(0) as u32;
                    let arg_type = self.type_resolver.resolve_type(type_id)?;
                    output.push_str(&format!(
                        "    {}: {},\n",
                        arg_name,
                        self.type_resolver.format_type(&arg_type)
                    ));
                }
            }

            output.push_str("    options?: {\n");
            output.push_str("      value?: number | bigint;\n");
            output.push_str("      gasLimit?: number | bigint;\n");
            output.push_str("      salt?: string;\n");
            output.push_str("    }\n");
            output.push_str(&format!("  ): Promise<{}>;\n\n", self.contract_name));
        }

        output.push_str("}\n\n");

        Ok(output)
    }

    /// Generate methods interface (queries and transactions)
    fn generate_methods_interface(&mut self) -> Result<String> {
        let mut output = String::new();

        output.push_str("// ========================================\n");
        output.push_str("// Contract Methods\n");
        output.push_str("// ========================================\n\n");

        let spec = self.get_spec_section();
        let messages = spec["messages"]
            .as_array()
            .context("Messages section missing")?;

        // Separate queries and transactions
        let mut queries = Vec::new();
        let mut transactions = Vec::new();

        for msg in messages {
            let mutates = msg["mutates"].as_bool().unwrap_or(false);
            if mutates {
                transactions.push(msg);
            } else {
                queries.push(msg);
            }
        }

        // Generate query methods interface
        output.push_str(&format!("export interface {}Queries {{\n", self.contract_name));

        for msg in queries {
            output.push_str(&self.generate_method_signature((*msg).clone(), false)?);
        }

        output.push_str("}\n\n");

        // Generate transaction methods interface
        output.push_str(&format!("export interface {}Transactions {{\n", self.contract_name));

        for msg in transactions {
            output.push_str(&self.generate_method_signature((*msg).clone(), true)?);
        }

        output.push_str("}\n\n");

        Ok(output)
    }

    /// Generate a method signature
    fn generate_method_signature(&mut self, msg: JsonValue, is_tx: bool) -> Result<String> {
        let mut output = String::new();

        let label = msg["label"].as_str().unwrap_or("method");
        let docs = msg["docs"].as_array();

        // JSDoc
        if let Some(docs) = docs {
            if !docs.is_empty() {
                output.push_str("  /**\n");
                for doc in docs {
                    if let Some(doc_str) = doc.as_str() {
                        output.push_str(&format!("   * {}\n", doc_str));
                    }
                }
                output.push_str("   */\n");
            }
        }

        // Method signature
        output.push_str(&format!("  {}(", label));

        // Arguments
        if let Some(args) = msg["args"].as_array() {
            if !args.is_empty() {
                output.push_str("\n");
                for arg in args {
                    let arg_name = arg["label"].as_str().unwrap_or("arg");
                    let type_id = arg["type"]["type"].as_u64().unwrap_or(0) as u32;
                    let arg_type = self.type_resolver.resolve_type(type_id)?;
                    output.push_str(&format!(
                        "    {}: {},\n",
                        arg_name,
                        self.type_resolver.format_type(&arg_type)
                    ));
                }
                output.push_str("  ");
            }
        }

        output.push_str(")");

        // Return type
        let return_type = if is_tx {
            "Promise<Transaction>".to_string()
        } else {
            let ret_type = if let Some(return_type) = msg.get("returnType") {
                if return_type.is_null() {
                    "void".to_string()
                } else if let Some(type_id) = return_type["type"].as_u64() {
                    let ts_type = self.type_resolver.resolve_type(type_id as u32)?;
                    self.type_resolver.format_type(&ts_type)
                } else {
                    "any".to_string()
                }
            } else {
                "void".to_string()
            };
            format!("Promise<{}>", ret_type)
        };

        output.push_str(&format!(": {};\n\n", return_type));

        Ok(output)
    }

    /// Generate events interface
    fn generate_events_interface(&mut self) -> Result<String> {
        let mut output = String::new();

        output.push_str("// ========================================\n");
        output.push_str("// Events\n");
        output.push_str("// ========================================\n\n");

        let spec = self.get_spec_section();

        if let Some(events) = spec["events"].as_array() {
            if events.is_empty() {
                output.push_str(&format!(
                    "export interface {}Events {{\n  // No events defined\n}}\n\n",
                    self.contract_name
                ));
                return Ok(output);
            }

            for event in events {
                let event_name = event["label"].as_str().unwrap_or("Event");
                let docs = event["docs"].as_array();

                // JSDoc
                if let Some(docs) = docs {
                    if !docs.is_empty() {
                        output.push_str("/**\n");
                        for doc in docs {
                            if let Some(doc_str) = doc.as_str() {
                                output.push_str(&format!(" * {}\n", doc_str));
                            }
                        }
                        output.push_str(" */\n");
                    }
                }

                // Event interface
                output.push_str(&format!("export interface {}Event {{\n", event_name));

                if let Some(args) = event["args"].as_array() {
                    for arg in args {
                        let arg_name = arg["label"].as_str().unwrap_or("value");
                        let indexed = arg["indexed"].as_bool().unwrap_or(false);
                        let type_id = arg["type"]["type"].as_u64().unwrap_or(0) as u32;
                        let arg_type = self.type_resolver.resolve_type(type_id)?;

                        let comment = if indexed { " // indexed" } else { "" };
                        output.push_str(&format!(
                            "  {}: {};{}\n",
                            arg_name,
                            self.type_resolver.format_type(&arg_type),
                            comment
                        ));
                    }
                }

                output.push_str("}\n\n");
            }

            // Events union type
            output.push_str(&format!("export interface {}Events {{\n", self.contract_name));
            for event in events {
                let event_name = event["label"].as_str().unwrap_or("Event");
                output.push_str(&format!("  {}: {}Event;\n", event_name, event_name));
            }
            output.push_str("}\n\n");
        } else {
            output.push_str(&format!(
                "export interface {}Events {{\n  // No events defined\n}}\n\n",
                self.contract_name
            ));
        }

        Ok(output)
    }

    /// Generate main contract interface
    fn generate_main_interface(&self) -> Result<String> {
        let mut output = String::new();

        output.push_str("// ========================================\n");
        output.push_str("// Main Contract Interface\n");
        output.push_str("// ========================================\n\n");

        output.push_str(&format!(
            r#"/**
 * Type-safe interface for the {} contract
 */
export interface {} {{
  /** Contract address */
  address: string;

  /** Read-only query methods */
  query: {}Queries;

  /** State-changing transaction methods */
  tx: {}Transactions;

  /** Event types */
  events: {}Events;

  /** Contract metadata */
  metadata: string;
}}
"#,
            self.contract_name,
            self.contract_name,
            self.contract_name,
            self.contract_name,
            self.contract_name
        ));

        Ok(output)
    }

    /// Helper to get spec section (handles both V3 and V4 format)
    fn get_spec_section(&self) -> JsonValue {
        if let Some(v3) = self.metadata.get("V3") {
            v3["spec"].clone()
        } else {
            self.metadata.get("spec").cloned().unwrap_or_else(|| self.metadata.clone())
        }
    }

    /// Check if two types are equal (for deduplication)
    fn types_equal(&self, a: &TypeScriptType, b: &TypeScriptType) -> bool {
        match (a, b) {
            (TypeScriptType::Interface { name: n1, .. }, TypeScriptType::Interface { name: n2, .. }) => n1 == n2,
            (TypeScriptType::Union { name: n1, .. }, TypeScriptType::Union { name: n2, .. }) => n1 == n2,
            _ => false,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn sample_metadata() -> JsonValue {
        serde_json::json!({
            "contract": {
                "name": "Flipper",
                "version": "1.0.0"
            },
            "spec": {
                "constructors": [
                    {
                        "label": "new",
                        "selector": "0x9bae9d5e",
                        "args": [
                            {
                                "label": "init_value",
                                "type": {
                                    "displayName": ["bool"],
                                    "type": 1
                                }
                            }
                        ],
                        "docs": ["Creates a new flipper."]
                    }
                ],
                "messages": [
                    {
                        "label": "flip",
                        "selector": "0x633aa551",
                        "mutates": true,
                        "args": [],
                        "returnType": null,
                        "docs": ["Flips the value."]
                    },
                    {
                        "label": "get",
                        "selector": "0x2f865bd9",
                        "mutates": false,
                        "args": [],
                        "returnType": {
                            "type": 1
                        },
                        "docs": ["Gets the value."]
                    }
                ],
                "events": []
            },
            "types": [
                {
                    "id": 1,
                    "type": {
                        "path": [],
                        "params": [],
                        "def": {
                            "primitive": "bool"
                        }
                    }
                }
            ]
        })
    }

    #[test]
    fn test_generate_header() {
        let metadata = sample_metadata();
        let generator = TypeScriptGenerator::new("Flipper", &metadata).unwrap();
        let header = generator.generate_header();
        assert!(header.contains("Flipper"));
        assert!(header.contains("DO NOT EDIT"));
    }

    #[test]
    fn test_generate_imports() {
        let metadata = sample_metadata();
        let generator = TypeScriptGenerator::new("Flipper", &metadata).unwrap();
        let imports = generator.generate_imports();
        assert!(imports.contains("@glin-forge/sdk"));
        assert!(imports.contains("Transaction"));
    }
}
