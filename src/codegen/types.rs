// TypeScript type generation from ink! contract metadata

use anyhow::Result;
use serde_json::Value as JsonValue;

/// Generate TypeScript interface definitions from contract ABI
pub fn generate_typescript_types(contract_name: &str, abi: &JsonValue) -> Result<String> {
    let messages = abi["spec"]["messages"]
        .as_array()
        .ok_or_else(|| anyhow::anyhow!("Invalid ABI: missing messages"))?;

    let mut query_methods = Vec::new();
    let mut tx_methods = Vec::new();

    for message in messages {
        let label = message["label"].as_str().unwrap_or("unknown");
        let mutates = message["mutates"].as_bool().unwrap_or(false);

        // Parse arguments
        let args = message["args"]
            .as_array()
            .map(|arr| {
                arr.iter()
                    .map(|arg| {
                        let name = arg["label"].as_str().unwrap_or("arg");
                        let type_info = parse_type(&arg["type"]);
                        format!("{}: {}", name, type_info)
                    })
                    .collect::<Vec<_>>()
                    .join(", ")
            })
            .unwrap_or_default();

        // Parse return type
        let return_type = message["returnType"]
            .as_object()
            .and_then(|rt| rt.get("type"))
            .map(parse_type)
            .unwrap_or_else(|| "void".to_string());

        let method_sig = format!("  {}: ({}) => Promise<{}>", label, args, return_type);

        if mutates {
            tx_methods.push(method_sig);
        } else {
            query_methods.push(method_sig);
        }
    }

    let ts_output = format!(
        r#"// Generated by glin-forge
// Do not edit manually

import {{ Contract, QueryResult, TxResult }} from '@glin-ai/sdk';

export interface {}ContractQuery {{
{}
}}

export interface {}ContractTx {{
{}
}}

export interface {}Contract {{
  query: {}ContractQuery;
  tx: {}ContractTx;
  address: string;
}}
"#,
        contract_name,
        query_methods.join("\n"),
        contract_name,
        tx_methods.join("\n"),
        contract_name,
        contract_name,
        contract_name
    );

    Ok(ts_output)
}

/// Parse ink! type to TypeScript type
fn parse_type(type_value: &JsonValue) -> String {
    // Simplified type parsing - maps ink! types to TypeScript types
    if let Some(display_name) = type_value.get("displayName").and_then(|v| v.as_array()) {
        if let Some(first) = display_name.first().and_then(|v| v.as_str()) {
            return match first {
                "u8" | "u16" | "u32" | "u64" | "u128" | "i8" | "i16" | "i32" | "i64" | "i128" => {
                    "bigint".to_string()
                }
                "String" | "str" => "string".to_string(),
                "bool" => "boolean".to_string(),
                "Vec" => "any[]".to_string(),
                "Option" => {
                    if let Some(inner) = display_name.get(1).and_then(|v| v.as_str()) {
                        format!("{} | null", inner)
                    } else {
                        "any | null".to_string()
                    }
                }
                _ => first.to_string(),
            };
        }
    }

    "any".to_string()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_type_primitives() {
        let type_u32 = serde_json::json!({
            "displayName": ["u32"]
        });
        assert_eq!(parse_type(&type_u32), "bigint");

        let type_bool = serde_json::json!({
            "displayName": ["bool"]
        });
        assert_eq!(parse_type(&type_bool), "boolean");

        let type_string = serde_json::json!({
            "displayName": ["String"]
        });
        assert_eq!(parse_type(&type_string), "string");
    }

    #[test]
    fn test_parse_type_option() {
        let type_option = serde_json::json!({
            "displayName": ["Option", "u32"]
        });
        assert_eq!(parse_type(&type_option), "u32 | null");
    }
}
