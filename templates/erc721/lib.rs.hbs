#![cfg_attr(not(feature = "std"), no_std, no_main)]

#[ink::contract]
mod {{contract_name}} {
    use ink::storage::Mapping;

    #[ink(storage)]
    pub struct {{contract_name_pascal}} {
        /// Token owner mapping
        token_owner: Mapping<TokenId, AccountId>,
        /// Balance of tokens per owner
        owned_tokens_count: Mapping<AccountId, u32>,
        /// Approved address for each token
        token_approvals: Mapping<TokenId, AccountId>,
        /// Operator approvals
        operator_approvals: Mapping<(AccountId, AccountId), bool>,
        /// Total supply
        total_supply: u32,
        /// Token URI base
        base_uri: String,
    }

    pub type TokenId = u32;

    #[ink(event)]
    pub struct Transfer {
        #[ink(topic)]
        from: Option<AccountId>,
        #[ink(topic)]
        to: Option<AccountId>,
        #[ink(topic)]
        token_id: TokenId,
    }

    #[ink(event)]
    pub struct Approval {
        #[ink(topic)]
        owner: AccountId,
        #[ink(topic)]
        approved: AccountId,
        #[ink(topic)]
        token_id: TokenId,
    }

    #[ink(event)]
    pub struct ApprovalForAll {
        #[ink(topic)]
        owner: AccountId,
        #[ink(topic)]
        operator: AccountId,
        approved: bool,
    }

    impl {{contract_name_pascal}} {
        #[ink(constructor)]
        pub fn new(base_uri: String) -> Self {
            Self {
                token_owner: Mapping::default(),
                owned_tokens_count: Mapping::default(),
                token_approvals: Mapping::default(),
                operator_approvals: Mapping::default(),
                total_supply: 0,
                base_uri,
            }
        }

        #[ink(message)]
        pub fn balance_of(&self, owner: AccountId) -> u32 {
            self.owned_tokens_count.get(&owner).unwrap_or(0)
        }

        #[ink(message)]
        pub fn owner_of(&self, token_id: TokenId) -> Option<AccountId> {
            self.token_owner.get(&token_id)
        }

        #[ink(message)]
        pub fn mint(&mut self, to: AccountId) -> Result<(), Error> {
            let token_id = self.total_supply;

            if self.token_owner.get(&token_id).is_some() {
                return Err(Error::TokenExists);
            }

            self.add_token_to(&to, token_id)?;
            self.total_supply += 1;

            self.env().emit_event(Transfer {
                from: None,
                to: Some(to),
                token_id,
            });

            Ok(())
        }

        #[ink(message)]
        pub fn transfer(&mut self, to: AccountId, token_id: TokenId) -> Result<(), Error> {
            let caller = self.env().caller();
            let owner = self.owner_of(token_id).ok_or(Error::TokenNotFound)?;

            if owner != caller {
                return Err(Error::NotOwner);
            }

            self.transfer_token_from(&owner, &to, token_id)?;

            Ok(())
        }

        #[ink(message)]
        pub fn approve(&mut self, to: AccountId, token_id: TokenId) -> Result<(), Error> {
            let caller = self.env().caller();
            let owner = self.owner_of(token_id).ok_or(Error::TokenNotFound)?;

            if owner != caller && !self.is_approved_for_all(owner, caller) {
                return Err(Error::NotOwner);
            }

            self.token_approvals.insert(token_id, &to);

            self.env().emit_event(Approval {
                owner,
                approved: to,
                token_id,
            });

            Ok(())
        }

        #[ink(message)]
        pub fn set_approval_for_all(&mut self, operator: AccountId, approved: bool) -> Result<(), Error> {
            let caller = self.env().caller();

            if caller == operator {
                return Err(Error::SelfApproval);
            }

            self.operator_approvals.insert((caller, operator), &approved);

            self.env().emit_event(ApprovalForAll {
                owner: caller,
                operator,
                approved,
            });

            Ok(())
        }

        #[ink(message)]
        pub fn transfer_from(&mut self, from: AccountId, to: AccountId, token_id: TokenId) -> Result<(), Error> {
            let caller = self.env().caller();

            if !self.is_approved_or_owner(caller, token_id) {
                return Err(Error::NotAuthorized);
            }

            self.transfer_token_from(&from, &to, token_id)?;

            Ok(())
        }

        #[ink(message)]
        pub fn token_uri(&self, token_id: TokenId) -> String {
            format!("{}/{}", self.base_uri, token_id)
        }

        #[ink(message)]
        pub fn total_supply(&self) -> u32 {
            self.total_supply
        }

        fn transfer_token_from(&mut self, from: &AccountId, to: &AccountId, token_id: TokenId) -> Result<(), Error> {
            self.remove_token_from(from, token_id)?;
            self.add_token_to(to, token_id)?;
            self.token_approvals.remove(token_id);

            self.env().emit_event(Transfer {
                from: Some(*from),
                to: Some(*to),
                token_id,
            });

            Ok(())
        }

        fn add_token_to(&mut self, to: &AccountId, token_id: TokenId) -> Result<(), Error> {
            let balance = self.balance_of(*to);
            self.owned_tokens_count.insert(to, &(balance + 1));
            self.token_owner.insert(token_id, to);
            Ok(())
        }

        fn remove_token_from(&mut self, from: &AccountId, token_id: TokenId) -> Result<(), Error> {
            let balance = self.balance_of(*from);
            if balance == 0 {
                return Err(Error::InsufficientBalance);
            }
            self.owned_tokens_count.insert(from, &(balance - 1));
            self.token_owner.remove(token_id);
            Ok(())
        }

        fn is_approved_or_owner(&self, spender: AccountId, token_id: TokenId) -> bool {
            let owner = match self.owner_of(token_id) {
                Some(owner) => owner,
                None => return false,
            };

            spender == owner
                || self.token_approvals.get(&token_id) == Some(spender)
                || self.is_approved_for_all(owner, spender)
        }

        fn is_approved_for_all(&self, owner: AccountId, operator: AccountId) -> bool {
            self.operator_approvals.get((owner, operator)).unwrap_or(false)
        }
    }

    #[derive(Debug, PartialEq, Eq, scale::Encode, scale::Decode)]
    #[cfg_attr(feature = "std", derive(scale_info::TypeInfo))]
    pub enum Error {
        TokenNotFound,
        NotOwner,
        NotAuthorized,
        TokenExists,
        SelfApproval,
        InsufficientBalance,
    }

    #[cfg(test)]
    mod tests {
        use super::*;

        #[ink::test]
        fn new_works() {
            let contract = {{contract_name_pascal}}::new("https://example.com/nft".to_string());
            assert_eq!(contract.total_supply(), 0);
        }

        #[ink::test]
        fn mint_works() {
            let mut contract = {{contract_name_pascal}}::new("https://example.com/nft".to_string());
            let accounts = ink::env::test::default_accounts::<ink::env::DefaultEnvironment>();

            assert!(contract.mint(accounts.alice).is_ok());
            assert_eq!(contract.balance_of(accounts.alice), 1);
            assert_eq!(contract.owner_of(0), Some(accounts.alice));
        }

        #[ink::test]
        fn transfer_works() {
            let mut contract = {{contract_name_pascal}}::new("https://example.com/nft".to_string());
            let accounts = ink::env::test::default_accounts::<ink::env::DefaultEnvironment>();

            assert!(contract.mint(accounts.alice).is_ok());
            assert!(contract.transfer(accounts.bob, 0).is_ok());
            assert_eq!(contract.owner_of(0), Some(accounts.bob));
        }
    }
}
